"""
The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response.
"""
directive @cost(
  """
  The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc.
  """
  weight: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"""
A directive used by the Apollo iOS client to annotate operations or fragments that should be used exclusively for generating local cache mutations instead of as standard operations.
"""
directive @apollo_client_ios_localCacheMutation on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""
A directive used by the Apollo iOS code generation engine to generate custom import statements in operation or fragment definition files. An import statement to import a module with the name provided in the `module` argument will be added to the generated definition file.
"""
directive @import(
  """The name of the module to import."""
  module: String!
) repeatable on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""Attach extra information to a given type."""
directive @typePolicy(
  """
  A selection set containing fields used to compute the cache key of an object. Referenced fields must have non-nullable scalar types. Order is important.
  """
  keyFields: String!
) on OBJECT | INTERFACE

"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""Defines when a policy shall be executed."""
enum ApplyPolicy {
  """Before the resolver was executed."""
  BEFORE_RESOLVER

  """After the resolver was executed."""
  AFTER_RESOLVER

  """The policy is applied in the validation step before the execution."""
  VALIDATION
}

type Query {
  currentUser: FullUser!
}

type Mutation {
  createBeginConnectionLink(redirectUri: String!): String!
  createConnectionLink(code: String!, redirectUri: String!): UserBankLink!
}

type FullUser {
  userId: String!
  name: String!
  enabled: Boolean!
}

type UserBankLink {
  id: ObjectId!
  userId: String!
  accessToken: String!
  refreshToken: String!
  expires: DateTime!
  scope: String!
  bank: BankProvider!
  bankId: String!
}

type BankProvider {
  id: String!
  name: String!
  logoUrl: String!
  consentExpires: DateTime!
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

type ObjectId {
  toByteArray: [Byte!]
  timestamp: Int!
  creationTime: DateTime!
}

"""
The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255.
"""
scalar Byte